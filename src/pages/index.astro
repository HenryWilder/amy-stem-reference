---
import { getCollection } from "astro:content";
import PageBase from "../layouts/PageBase.astro";
import {
    kinds,
    getChildren,
    getChildrenOfKind,
    getParent,
    type GlossaryEntry,
    type Kind,
    type GlossaryRef,
    type ChildOfGlossaryRef,
    type GlossaryEntryOfKind,
    type ChildOfGlossaryEntry,
    type GlossarySlug,
    type ChildOfGlossarySlug
} from "../scripts/glossary";
import ScopeBlock from "../components/ScopeBlock.astro";
import Ref from "../components/Ref.astro";
import Keyword from "../components/syntax/Keyword.astro";
import Comment from "../components/syntax/Comment.astro";
import TypeUnion from "../components/TypeUnion.astro";
import LilRef from "../components/LilRef.astro";
import RefPath from "../components/RefPath.astro";
import { getEntry } from "astro:content";
import { getEntries } from "astro:content";
import Join from "../components/Join.astro";
import ScopeInline from "../components/ScopeInline.astro";
import Katex from "../components/Katex.astro";

interface GlossaryTreeNode {
    item: GlossaryEntry;
    childrenByKind: [Kind, GlossaryTreeNode[]][];
}

const getChildrenRecursively = async (root: GlossaryEntry): Promise<GlossaryTreeNode> => {
    const item: GlossaryEntry = root;

    const immediateChildrenByKind: [Kind, GlossaryEntry[]][] = await Promise.all(kinds
        .map(async (kind) => {
            const childItems: GlossaryEntry[] = await getChildrenOfKind(item.slug, kind);
            return [kind, childItems];
        })
    );

    const whereExisting: [Kind, GlossaryEntry[]][] = immediateChildrenByKind
        .filter(([_, entries]) => entries.length !== 0);

    const childrenByKindRecursively: [Kind, GlossaryTreeNode[]][] = await Promise.all(whereExisting
        .map(async ([kind, entries]: [Kind, GlossaryEntry[]]) => {
            const recursiveChildren: GlossaryTreeNode[] = await Promise.all(entries.map(getChildrenRecursively));
            const sortedChildren: GlossaryTreeNode[] = recursiveChildren.sort(({ item: a }: GlossaryTreeNode, { item: b }: GlossaryTreeNode) => {
                console.log(`${a.slug} requires [${a.data.requires.map(({slug}) => slug).join(', ')}] and ${b.slug} requires [${b.data.requires.map(({slug}) => slug).join(', ')}]`);
                if (a.data.requires.map(({slug})=>slug).includes(b.slug)) {
                    console.log(`${a.slug} is > ${b.slug}`);
                    return 1;
                }
                if (b.data.requires.map(({slug})=>slug).includes(a.slug)) {
                    console.log(`${a.slug} is < ${b.slug}`);
                    return -1;
                }
                console.log(`${a.slug} is neither < nor > ${b.slug}`);
                return a.slug.localeCompare(b.slug);
            });
            return [kind, sortedChildren];
        })
    );

    const node: GlossaryTreeNode = { item, childrenByKind: childrenByKindRecursively };
    return node;
};

const modules = await getCollection('glossary', (entry) => !entry.slug.includes('/'));
console.log(modules);

const tree: GlossaryTreeNode[] = await Promise.all(modules.map(getChildrenRecursively));

// Debug
const debugTreeRecursively = (nodes: GlossaryTreeNode[]) => {
    nodes.forEach((node: GlossaryTreeNode) => {
        console.group('- ' + node.item.slug.split('/').at(-1));
        node.childrenByKind.forEach(([kind, children]: [Kind, GlossaryTreeNode[]]) => {
            console.log(kind);
            debugTreeRecursively(children);
        });
        console.groupEnd();
    });
}
debugTreeRecursively(tree);
---

<!-- <Katex tex={`{\\color{deepskyblue}{f}} ({\\color{lightgreen}{${anim('x', 'y', 'z')}}}) = 2{\\color{tomato}{${anim('x', 'y', 'z', 'w')}}}`}/> -->

<PageBase title="Amy's STEM Notes">
    <Fragment slot="head">
        <style>
            main {
                display: flex;
                flex-flow: row nowrap;
                gap: 3em;
            }
        </style>
        <script>
            // Open details recursively when linking to a closed part of the page
            window.addEventListener('hashchange', (event: HashChangeEvent) => {
                // console.log(`hash changed: ${event.newURL}`);
                const id = event.newURL.slice(event.newURL.indexOf('#')).replace(/\+/g, '\\2b');
                const query = `details:has(${id})`;
                // console.log(`id: '${id}' query: ${query}`);
                const elements = document.querySelectorAll(query);
                // console.debug(elements);
                for (const element of elements) {
                    // console.debug(element);
                    element.setAttribute('open', 'true');
                    // console.debug(element);
                }
            });
        </script>
    </Fragment>
    <main>
    {() => {
        const renderTree = async (nodes: GlossaryTreeNode[]) => {
            return nodes.map(async (node: GlossaryTreeNode) => {
                const { item } = node;
                const renderedChildren = await Promise.all(node.childrenByKind.map(
                    async ([kind, children]): Promise<[Kind, any[]]> => [kind, await renderTree(children)]
                ));
                const Description = (await item.render()).Content;
                return <>
                    <ScopeBlock>
                        {/* Title */}
                        <Fragment slot="summary">
                                {async () => {
                                    const id = item.slug.replace(/\//g, '+');

                                    const parentItem = await getParent(item);

                                    const aliasRefs = item.data.aliases &&
                                        Object.entries(item.data.aliases).map(([alias, aliasKind]) =>
                                            <LilRef item={item} overrideKind={aliasKind}>
                                                {alias}
                                            </LilRef>
                                        );

                                    const info = await (async () => {
                                        switch (item.data.kind) {
                                            // Methods
                                            case 'function':
                                                type ParameterEntry = GlossaryEntryOfKind<'parameter'>;
                                                type ReturnEntry = GlossaryEntryOfKind<'return'>;
                                                type ReturnOrParameter = ReturnEntry | ParameterEntry;

                                                const parameters: ParameterEntry[] =
                                                    (await getChildrenOfKind(item.slug, 'parameter'));

                                                const returns: ReturnEntry[] =
                                                    (await getChildrenOfKind(item.slug, 'return'));

                                                const ioList = (delim: 'paren' | 'brace', source: ReturnOrParameter[]) =>
                                                    <ScopeBlock delim={delim} horizontal>
                                                        <Join list={source}>
                                                            {(srcItem: ReturnOrParameter) => {
                                                                const param = <Ref item={srcItem}/>;
                                                                const paramType = <TypeUnion list={srcItem.data.typeUnion}/>;
                                                                return <>
                                                                    {param}<Keyword
                                                                        tkn="type annotation"
                                                                        prev={param}
                                                                        next={paramType}
                                                                    />
                                                                    {paramType}
                                                                </>
                                                            }}
                                                            <span slot="separator">
                                                                {([prevProps, _prev]: [GlossaryEntry, any], [nextProps, _next]: [GlossaryEntry, any]) => {
                                                                    const prev = <Ref item={prevProps}/>;
                                                                    const next = <Ref item={nextProps}/>;
                                                                    return <><Keyword tkn="separator" prev={prev} next={next}/> </>
                                                                }}
                                                            </span>
                                                        </Join>
                                                    </ScopeBlock>;

                                                // const implies = <ScopeInline delim="{}"><span style="color:gray">...</span></ScopeInline>;

                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item}/>
                                                    <div class="function-signature">
                                                        {ioList('paren', parameters)}
                                                        <span style="font-size:2em">
                                                            <Keyword tkn="becomes" prev={ioList('paren', parameters)} next={ioList('brace', returns)}/>
                                                        </span>
                                                        {ioList('brace', returns)}
                                                        {/* <span style="font-size:2em">
                                                            <Keyword tkn="implies" prev={ioList('brace', returns)} next={implies}/>
                                                        </span> */}
                                                    </div>
                                                </>;

                                            // Fields
                                            case 'field':
                                                const field = <Ref item={item}/>;
                                                const fieldType = <TypeUnion list={item.data.typeUnion!}/>;
                                                return <>
                                                    <Keyword tkn={item.data.kind} what={field}/>
                                                    {field}<Keyword tkn="type annotation" prev={field} next={fieldType}/>
                                                    {fieldType}<Keyword tkn="end of statement"/>
                                                </>;

                                            // Parameters and Returns
                                            case 'parameter':
                                            case 'return':
                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <ScopeInline delim="{}" typeScope>
                                                        <TypeUnion list={item.data.typeUnion!}/>
                                                    </ScopeInline>
                                                    <Ref item={item}/>
                                                </>;

                                            // Types and Traits
                                            case 'type':
                                            case 'trait':
                                                const traits = 'traits' in item.data && await getEntries(item.data.traits);

                                                const traitOrType = <Ref item={item}/>;

                                                const traitList = traits && <Join list={traits}>
                                                    {(trait: GlossaryEntry) => <LilRef item={trait}/>}
                                                    <span slot="separator">
                                                        {([_prevProps, prev]: [GlossaryEntry, any], [_nextProps, next]: [GlossaryEntry, any]) =>
                                                            <>&nbsp;<Keyword tkn="combine traits" prev={prev} next={next}/>&nbsp;</>
                                                        }
                                                    </span>
                                                </Join>;

                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    {traitOrType}
                                                    {'traits' in item.data && item.data.traits.length !== 0 && <>
                                                        <Keyword tkn="implements" prev={traitOrType} next={traitList}/>
                                                        {traitList}
                                                    </>}
                                                </>;

                                            // Default
                                            default:
                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item}/>
                                                </>;
                                        }
                                    })();

                                    return <>
                                        <Comment hDepth={1} id={id}>
                                            <LilRef item={item}/>
                                            <Fragment slot="tooltip">
                                                The <Keyword tkn={item.data.kind}/> by the name of "<LilRef item={item}/>".
                                                <br/>
                                                {aliasRefs.length !== 0 && <>
                                                    (aka {aliasRefs[0]}{aliasRefs.slice(1).map((ref) => <>, {ref}</>)})
                                                </>}
                                                <br/>
                                                <br/>
                                                {parentItem && <>
                                                    Associated with <Keyword tkn={parentItem.data.kind}/> <RefPath item={parentItem}/>.
                                                </>}
                                            </Fragment>
                                        </Comment>
                                        {item.data.isStatic && <Keyword tkn="static"/>} {info}
                                    </>
                                }}
                        </Fragment>

                        {/* Aliases */}
                        {Object.keys(item.data.aliases).length !== 0 && <>
                            <Comment hDepth={2}>
                                Aliases
                                <Fragment slot="tooltip">
                                    Other names <LilRef item={item}/> may go by.
                                </Fragment>
                            </Comment>
                            <table class="alias-list">{
                                Object.entries(item.data.aliases).map(([alias, kind]) => {
                                    const aliasRef = <Ref item={item} overrideKind={kind} alias>{alias}</Ref>;
                                    const aliasing = <Ref item={item}/>;
                                    return <tr>
                                        <td>
                                            {/* All aliases are static */}
                                            <Keyword tkn="static"/>
                                            <Keyword tkn={kind}/>
                                        </td>
                                        <td>
                                            &nbsp;{aliasRef}
                                        </td>
                                        <td>
                                            &nbsp;<Keyword tkn={kind === item.data.kind ? 'assign' : 'similar to'} prev={aliasRef} next={aliasing}/>
                                            {aliasing}<Keyword tkn="end of statement"/>
                                        </td>
                                    </tr>
                                })
                            }</table>
                        </>}

                        {/* Description */}
                        <Comment hDepth={2}>
                            Description
                            <Fragment slot="tooltip">
                                Description of <Keyword tkn={item.data.kind}/> <LilRef item={item}/>.
                            </Fragment>
                        </Comment>
                        <div class="item-description">
                            <Katex tex={`\\text{${item.data.brief}}`}/>
                        </div>
                        <div class="item-description">
                            <Description/>
                        </div>

                        {/* Notation */}
                        {'notation' in item.data && <>
                            <Comment hDepth={2}>
                                Notation
                                <Fragment slot="tooltip">
                                    Notation for <Keyword tkn={item.data.kind}/> <LilRef item={item}/>.
                                </Fragment>
                            </Comment>
                            <div class="item-description">
                                <Katex tex={'\\Large ' + item.data.notation}/>
                            </div>
                        </>}

                        {/* Examples */}
                        {'examples' in item.data && item.data.examples && <>
                            <Comment hDepth={2}>
                                Examples
                                <Fragment slot="tooltip">
                                    Examples of <Keyword tkn={item.data.kind}/> <LilRef item={item}/>.
                                </Fragment>
                            </Comment>
                            <Katex tex={
                                '\\large \\begin{matrix*}[l]' +
                                item.data.examples.map((ex) => typeof ex !== 'string'
                                    ? `${ex.math}\\\\[-0.25em]\\textit{\\footnotesize\\gray{${ex.name}}}`
                                    : ex
                                ).join('\\\\[1.5em]') +
                                '\\end{matrix*}'
                            }/>
                        </>}

                        {/* Children */}
                        {renderedChildren.map(([kind, childrenOfKind]) => {
                            const mapping = {
                                function: {
                                    text: 'Methods',
                                    desc: 'Member functions associated with',
                                },
                                type: {
                                    text: 'Types',
                                    desc: 'Subtypes of',
                                },
                                field: {
                                    text: 'Fields',
                                    desc: 'Member variables on',
                                },
                                parameter: {
                                    text: 'Arguments',
                                    desc: 'Inputs to',
                                },
                                return: {
                                    text: 'Returns',
                                    desc: 'Outputs from',
                                },
                                trait: {
                                    text: 'Traits',
                                    desc: 'Member traits from',
                                },
                                constant: {
                                    text: 'Constants',
                                    desc: 'Constants associated with',
                                },
                                // unused
                                module: {
                                    text: 'Modules',
                                    desc: '[ERROR]',
                                },
                            };
                            const { text, desc } = mapping[kind];
                            return <>
                                <Comment hDepth={2}>
                                    {text}
                                    <Fragment slot="tooltip">
                                        {desc} the <LilRef item={item}/> {item.data.kind}.
                                    </Fragment>
                                </Comment>
                                <div class="columns">
                                    {childrenOfKind}
                                </div>
                            </>
                        })}
                    </ScopeBlock>
                </>
            });
        }
        return tree.map((module) => <div class="module-column">{renderTree([module])}</div>);
    }}
    </main>
</PageBase>
