---
import { getCollection } from "astro:content";
import PageBase from "../layouts/PageBase.astro";
import { kinds, type GlossaryEntry, type Kind, getChildren, getParent } from "../scripts/glossary";
import ScopeBlock from "../components/ScopeBlock.astro";
import Ref from "../components/Ref.astro";
import Keyword from "../components/syntax/Keyword.astro";
import Comment from "../components/syntax/Comment.astro";
import TypeUnion from "../components/TypeUnion.astro";
import LilRef from "../components/LilRef.astro";
import RefPath from "../components/RefPath.astro";
import { getEntry } from "astro:content";
import { getEntries } from "astro:content";
import Join from "../components/Join.astro";

interface GlossaryTreeNode {
    item: GlossaryEntry;
    childrenByKind: [Kind, GlossaryTreeNode[]][];
}

const getChildrenRecursively = async (root: GlossaryEntry): Promise<GlossaryTreeNode> => {
    const item: GlossaryEntry = root;

    const immediateChildrenByKind: [Kind, GlossaryEntry[]][] = await Promise.all(kinds
        .map(async (kind) => {
            const childItems: GlossaryEntry[] = await getChildren(item.slug, (entry) => entry.data.kind === kind);
            return [kind, childItems];
        })
    );

    const whereExisting: [Kind, GlossaryEntry[]][] = immediateChildrenByKind
        .filter(([_, entries]) => entries.length !== 0);

    const childrenByKindRecursively: [Kind, GlossaryTreeNode[]][] = await Promise.all(whereExisting
        .map(async ([kind, entries]: [Kind, GlossaryEntry[]]) => {
            const recursiveChildren: GlossaryTreeNode[] = await Promise.all(entries.map(getChildrenRecursively));
            return [kind, recursiveChildren];
        })
    );

    const node: GlossaryTreeNode = { item, childrenByKind: childrenByKindRecursively };
    return node;
};

const modules = await getCollection('glossary', (entry) => !entry.slug.includes('/'));

const tree: GlossaryTreeNode[] = await Promise.all(modules.map(getChildrenRecursively));

// Debug
const debugTreeRecursively = (nodes: GlossaryTreeNode[]) => {
    nodes.forEach((node: GlossaryTreeNode) => {
        console.group('- ' + node.item.slug.split('/').at(-1));
        node.childrenByKind.forEach(([kind, children]: [Kind, GlossaryTreeNode[]]) => {
            console.log(kind);
            debugTreeRecursively(children);
        });
        console.groupEnd();
    });
}
// debugTreeRecursively(tree);
---

<!-- <Katex tex={`{\\color{deepskyblue}{f}} ({\\color{lightgreen}{${anim('x', 'y', 'z')}}}) = 2{\\color{tomato}{${anim('x', 'y', 'z', 'w')}}}`}/> -->

<PageBase title="Amy's STEM Notes">
    <Fragment slot="head">
        <style>
            main {
                display: flex;
                flex-flow: row nowrap;
                gap: 3em;
            }
        </style>
        <script>
            // Open details recursively when linking to a closed part of the page
            window.addEventListener('hashchange', (event: HashChangeEvent) => {
                // console.log(`hash changed: ${event.newURL}`);
                const id = event.newURL.slice(event.newURL.indexOf('#')).replace(/\+/g, '\\2b');
                const query = `details:has(${id})`;
                // console.log(`id: '${id}' query: ${query}`);
                const elements = document.querySelectorAll(query);
                // console.debug(elements);
                for (const element of elements) {
                    // console.debug(element);
                    element.setAttribute('open', 'true');
                    // console.debug(element);
                }
            });
        </script>
    </Fragment>
    <Join list={['apple', 'orange', 'banana', 'mango']}>
        {(item: string, _index: number, _list: string[], _isFinal: boolean) => item}
        <span slot="separator">
            {(_item: string, _sepIndex: number, _list: string[], _prevItem: string, isFinal: boolean) => isFinal ? ' and ' : ', '}
        </span>
    </Join>
    <main>
    {() => {
        const renderTree = async (nodes: GlossaryTreeNode[], depth: number) => {
            return nodes.map(async (node: GlossaryTreeNode) => {
                const { item } = node;
                const renderedChildren = await Promise.all(node.childrenByKind.map(
                    async ([kind, children]): Promise<[Kind, any[]]> => [kind, await renderTree(children, depth + 2)]
                ));
                const Description = (await item.render()).Content;
                const innerDepth = depth + 1;
                return <>
                    <ScopeBlock>
                        {/* Title */}
                        <Fragment slot="summary">
                                {async () => {
                                    const id = item.slug.replace(/\//g, '+');

                                    const parentItem = await getParent(item);

                                    const aliasRefs = item.data.aliases &&
                                        Object.entries(item.data.aliases).map(([alias, aliasKind]) =>
                                            <LilRef item={item} overrideKind={aliasKind}>
                                                {alias}
                                            </LilRef>
                                        );

                                    const info = await (async () => {
                                        switch (item.data.kind) {
                                            // Methods
                                            case 'function':
                                                const parameters =
                                                    await getChildren(item.slug, (child) => child.data.kind === 'parameter');

                                                const returns =
                                                    await getChildren(item.slug, (child) => child.data.kind === 'return');

                                                const ioList = (delim: 'paren' | 'brace', source: GlossaryEntry[]) =>
                                                    <ScopeBlock delim={delim} horizontal>
                                                        <table class="parameter-list">{
                                                            source.map((srcItem) => <tr>
                                                                <td><Ref item={srcItem}/><Keyword tkn="type annotation"/></td>
                                                                <td><TypeUnion list={srcItem.data.typeUnion!}/><Keyword tkn="separator"/></td>
                                                            </tr>
                                                        )}</table>
                                                    </ScopeBlock>;

                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item}/>
                                                    <div class="function-signature">
                                                        {ioList('paren', parameters)}
                                                        <span style="font-size:2em">
                                                            <Keyword tkn="becomes"/>
                                                        </span>
                                                        {ioList('brace', returns)}
                                                        <span style="font-size:2em">
                                                            <Keyword tkn="implies"/>
                                                        </span>
                                                    </div>
                                                </>;

                                            // Fields
                                            case 'field':
                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item}/><Keyword tkn="type annotation"/>
                                                    <TypeUnion list={item.data.typeUnion!}/><Keyword tkn="end of statement"/>
                                                </>;

                                            // Parameters and Returns
                                            case 'parameter':
                                            case 'return':
                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <span class="type">&lbrace;</span>
                                                    <TypeUnion list={item.data.typeUnion!}/>
                                                    <span class="type">&rbrace;</span>
                                                    <Ref item={item}/>
                                                </>;

                                            // Types and Traits
                                            case 'type':
                                            case 'trait':
                                                const traits = item.data.traits && await getEntries(item.data.traits);
                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item}/>
                                                    {item.data.traits && <>
                                                        <Keyword tkn="implements"/>
                                                        {traits && <>
                                                            <LilRef item={traits[0]}/>{traits.slice(1).map((trait) => {
                                                                return <>&nbsp;<Keyword tkn="combine traits"/> <LilRef item={trait}/></>;
                                                            })}
                                                        </>}
                                                    </>}
                                                </>;

                                            // Default
                                            default:
                                                return <>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item}/>
                                                </>;
                                        }
                                    })();

                                    return <>
                                        <Comment hDepth={depth} id={id}>
                                            The "<LilRef item={item}/>" {item.data.kind}
                                            <Fragment slot="tooltip">
                                                The {item.data.kind} by the name of "<LilRef item={item}/>"
                                                    {aliasRefs && <>(aka {aliasRefs[0]}{aliasRefs.slice(1).map((ref) => <>, {ref}</>)})</>}<br/>
                                                {parentItem && <>associated with the <RefPath item={parentItem}/> {parentItem.data.kind}</>}
                                            </Fragment>
                                        </Comment>
                                        {item.data.isStatic && <Keyword tkn="static"/>} {info}
                                    </>
                                }}
                        </Fragment>

                        {/* Aliases */}
                        {item.data.aliases && <>
                            <Comment hDepth={innerDepth}>
                                Aliases
                                <Fragment slot="tooltip">
                                    Other names <LilRef item={item}/> may go by
                                </Fragment>
                            </Comment>
                            <table class="alias-list">{
                                Object.entries(item.data.aliases).map(([alias, kind]) => <tr>
                                    <td>
                                        {/* All aliases are static */}
                                        <Keyword tkn="static"/>
                                        <Keyword tkn={kind}/>
                                    </td>
                                    <td>
                                        &nbsp;<Ref item={item} overrideKind={kind} alias>{alias}</Ref>
                                    </td>
                                    <td>
                                        &nbsp;<Keyword tkn={kind === item.data.kind ? 'assign' : 'similar to'}/>
                                        <Ref item={item}/><Keyword tkn="end of statement"/>
                                    </td>
                                </tr>)
                            }</table>
                        </>}

                        {/* Description */}
                        <Comment hDepth={innerDepth}>
                            Description
                            <Fragment slot="tooltip">
                                Description of the <LilRef item={item}/> {item.data.kind}
                            </Fragment>
                        </Comment>
                        <div class="item-description">
                            <Description/>
                        </div>

                        {/* Children */}
                        {renderedChildren.map(([kind, childrenOfKind]) => {
                            const mapping = {
                                function: {
                                    text: 'Methods',
                                    desc: 'Member functions associated with',
                                },
                                type: {
                                    text: 'Types',
                                    desc: 'Subtypes of',
                                },
                                field: {
                                    text: 'Fields',
                                    desc: 'Member variables on',
                                },
                                parameter: {
                                    text: 'Arguments',
                                    desc: 'Inputs to',
                                },
                                return: {
                                    text: 'Returns',
                                    desc: 'Outputs from',
                                },
                                trait: {
                                    text: 'Traits',
                                    desc: 'Member traits from',
                                },
                                constant: {
                                    text: 'Constants',
                                    desc: 'Constants associated with',
                                },
                                // unused
                                module: {
                                    text: 'Modules',
                                    desc: '[ERROR]',
                                },
                            };
                            const { text, desc } = mapping[kind];
                            return <>
                                <Comment hDepth={innerDepth}>
                                    {text}
                                    <Fragment slot="tooltip">
                                        {desc} the <LilRef item={item}/> {item.data.kind}
                                    </Fragment>
                                </Comment>
                                {childrenOfKind}
                            </>
                        })}
                    </ScopeBlock>
                </>
            });
        }
        return tree.map((module) => <div class="module-column">{renderTree([module], 1)}</div>);
    }}
    </main>
</PageBase>
