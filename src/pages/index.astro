---
import { getCollection } from "astro:content";
import PageBase from "../layouts/PageBase.astro";
import { kinds, type GlossaryEntry, type Kind, type ValidGlossarySlug, getChildren, getParent } from "../scripts/glossary";
import ScopeBlock from "../components/ScopeBlock.astro";
import Ref from "../components/Ref.astro";
import Keyword from "../components/syntax/Keyword.astro";
import Comment from "../components/syntax/Comment.astro";
import Heading from "../components/Heading.astro";
import TypeUnion from "../components/TypeUnion.astro";
import ScopeInline from "../components/ScopeInline.astro";
import Tooltip from "../components/Tooltip.astro";
import LilRef from "../components/LilRef.astro";
import RefPath from "../components/RefPath.astro";

interface GlossaryTreeNode {
    item: GlossaryEntry;
    childrenByKind: [Kind, GlossaryTreeNode[]][];
}

const getChildrenRecursively = async (root: GlossaryEntry): Promise<GlossaryTreeNode> => {
    const item: GlossaryEntry = root;

    const immediateChildrenByKind: [Kind, GlossaryEntry[]][] = await Promise.all(kinds
        .map(async (kind) => {
            const childItems: GlossaryEntry[] = await getChildren(item.slug, (entry) => entry.data.kind === kind);
            return [kind, childItems];
        })
    );

    const whereExisting: [Kind, GlossaryEntry[]][] = immediateChildrenByKind
        .filter(([_, entries]) => entries.length !== 0);

    const childrenByKindRecursively: [Kind, GlossaryTreeNode[]][] = await Promise.all(whereExisting
        .map(async ([kind, entries]: [Kind, GlossaryEntry[]]) => {
            const recursiveChildren: GlossaryTreeNode[] = await Promise.all(entries.map(getChildrenRecursively));
            return [kind, recursiveChildren];
        })
    );

    const node: GlossaryTreeNode = { item, childrenByKind: childrenByKindRecursively };
    return node;
};

const modules = await getCollection('glossary', (entry) => !entry.slug.includes('/'));

const tree: GlossaryTreeNode[] = await Promise.all(modules.map(getChildrenRecursively));

// Debug
const debugTreeRecursively = (nodes: GlossaryTreeNode[]) => {
    nodes.forEach((node: GlossaryTreeNode) => {
        console.group('- ' + node.item.slug.split('/').at(-1));
        node.childrenByKind.forEach(([kind, children]: [Kind, GlossaryTreeNode[]]) => {
            console.log(kind);
            debugTreeRecursively(children);
        });
        console.groupEnd();
    });
}
debugTreeRecursively(tree);
---

<!-- <Katex tex={`{\\color{deepskyblue}{f}} ({\\color{lightgreen}{${anim('x', 'y', 'z')}}}) = 2{\\color{tomato}{${anim('x', 'y', 'z', 'w')}}}`}/> -->

<PageBase title="Amy's STEM Notes">
    <Fragment slot="head">
        <style>
            main {
                display: flex;
                flex-flow: row nowrap;
                gap: 3em;
            }
        </style>
        <script>
            // Open details recursively when linking to a closed part of the page
            window.addEventListener('hashchange', (event: HashChangeEvent) => {
                // console.log(`hash changed: ${event.newURL}`);
                const id = event.newURL.slice(event.newURL.indexOf('#')).replace(/\+/g, '\\2b');
                const query = `details:has(${id})`;
                // console.log(`id: '${id}' query: ${query}`);
                const elements = document.querySelectorAll(query);
                // console.debug(elements);
                for (const element of elements) {
                    // console.debug(element);
                    element.setAttribute('open', 'true');
                    // console.debug(element);
                }
            });
        </script>
    </Fragment>
    <main>
    {() => {
        const renderTree = async (nodes: GlossaryTreeNode[], depth: number) => {
            return nodes.map(async (node: GlossaryTreeNode) => {
                const { item } = node;
                const renderedChildren = await Promise.all(node.childrenByKind.map(
                    async ([kind, children]): Promise<[Kind, any[]]> => [kind, await renderTree(children, depth + 2)]
                ));
                const Description = (await item.render()).Content;
                const innerDepth = depth + 1;
                return <>
                    <ScopeBlock>
                        {/* Title */}
                        <Fragment slot="summary">
                                {async () => {
                                    const id = item.slug.replace(/\//g, '+');

                                    const parentItem = await getParent(item);

                                    const aliasRefs = item.data.aliases &&
                                        Object.entries(item.data.aliases).map(([alias, aliasKind]) =>
                                            <LilRef item={item} overrideKind={aliasKind} onPage>
                                                {alias}
                                            </LilRef>
                                        );

                                    const comment =
                                        <Comment hDepth={depth} id={id}>
                                            The "<LilRef item={item} onPage/>" {item.data.kind}
                                            <Fragment slot="tooltip">
                                                The {item.data.kind} by the name of "<LilRef item={item} onPage/>"
                                                    {aliasRefs && <>(aka {aliasRefs[0]}{aliasRefs.slice(1).map((ref) => <>, {ref}</>)})</>}<br/>
                                                {parentItem && <>associated with the <RefPath item={parentItem} onPage/> {parentItem.data.kind}</>}
                                            </Fragment>
                                        </Comment>;

                                    switch (item.data.kind) {
                                        // Methods
                                        case 'function':
                                            const parameters =
                                                await getChildren(item.slug, (child) => child.data.kind === 'parameter');

                                            const returns =
                                                await getChildren(item.slug, (child) => child.data.kind === 'return');

                                            const ioList = (delim: 'paren' | 'brace', source: GlossaryEntry[]) =>
                                                <ScopeBlock delim={delim} horizontal>
                                                    <table class="parameter-list">{
                                                        source.map((srcItem) => <tr>
                                                            <td><Ref item={srcItem} onPage/><Keyword tkn="type annotation"/></td>
                                                            <td><TypeUnion list={srcItem.data.typeUnion!} onPage/><Keyword tkn="separator"/></td>
                                                        </tr>
                                                    )}</table>
                                                </ScopeBlock>;

                                            return <>
                                                {comment}
                                                {item.data.isStatic && <><Keyword tkn="static"/>&nbsp;</>}
                                                <Keyword tkn={item.data.kind}/>
                                                <Ref item={item} onPage/>
                                                <div class="function-signature">
                                                    {ioList('paren', parameters)}
                                                    <span style="font-size:2em">
                                                        <Keyword tkn="becomes"/>
                                                    </span>
                                                    {ioList('brace', returns)}
                                                    <span style="font-size:2em">
                                                        <Keyword tkn="implies"/>
                                                    </span>
                                                </div>
                                            </>;

                                        // Fields
                                        case 'field':
                                            return <>
                                                {comment}
                                                {item.data.isStatic && <><Keyword tkn="static"/>&nbsp;</>}
                                                <Keyword tkn={item.data.kind}/>
                                                <Ref item={item} onPage/><Keyword tkn="type annotation"/>
                                                <TypeUnion list={item.data.typeUnion!} onPage/><Keyword tkn="end of statement"/>
                                            </>;

                                        // Parameters and Returns
                                        case 'parameter':
                                        case 'return':
                                            return <>
                                                {comment}
                                                {item.data.isStatic && <><Keyword tkn="static"/>&nbsp;</>}
                                                <Keyword tkn={item.data.kind}/>
                                                <span class="type">&lbrace;</span>
                                                <TypeUnion list={item.data.typeUnion!} onPage/>
                                                <span class="type">&rbrace;</span>
                                                <Ref item={item} onPage/>
                                            </>;

                                        // Types and Traits
                                        case 'type':
                                        case 'trait':
                                            return <>
                                                {comment}
                                                {item.data.isStatic && <><Keyword tkn="static"/>&nbsp;</>}
                                                <Keyword tkn={item.data.kind}/>
                                                <Ref item={item} onPage/>
                                            </>;

                                        // Default
                                        default:
                                            return <>
                                                {comment}
                                                {item.data.isStatic && <><Keyword tkn="static"/>&nbsp;</>}
                                                <Keyword tkn={item.data.kind}/>
                                                <Ref item={item} onPage/>
                                            </>;
                                    }
                                }}
                        </Fragment>

                        {/* Aliases */}
                        {item.data.aliases && <>
                            <Comment hDepth={innerDepth}>
                                Aliases
                                <Fragment slot="tooltip">
                                    Other names <LilRef item={item} onPage/> may go by
                                </Fragment>
                            </Comment>
                            <table class="alias-list">{
                                Object.entries(item.data.aliases).map(([alias, kind]) => <tr>
                                    <td><Keyword tkn="static"/> <Keyword tkn={kind}/></td>
                                    <td>&nbsp;<Ref item={item} overrideKind={kind} onPage alias>{alias}</Ref></td>
                                    <td>&nbsp;<Keyword tkn={kind === item.data.kind ? 'assign' : 'similar to'}/>&nbsp;<Ref item={item} onPage/><Keyword tkn="end of statement"/></td>
                                </tr>)
                            }</table>
                        </>}

                        {/* Description */}
                        <Comment hDepth={innerDepth}>
                            Description
                            <Fragment slot="tooltip">
                                Description of the <LilRef item={item} onPage/> {item.data.kind}
                            </Fragment>
                        </Comment>
                        <div class="item-description">
                            <Description/>
                        </div>

                        {/* Children */}
                        {renderedChildren.map(([kind, childrenOfKind]) => {
                            const mapping = {
                                function: {
                                    text: 'Methods',
                                    desc: 'Member functions associated with',
                                },
                                type: {
                                    text: 'Types',
                                    desc: 'Subtypes of',
                                },
                                field: {
                                    text: 'Fields',
                                    desc: 'Member variables on',
                                },
                                parameter: {
                                    text: 'Arguments',
                                    desc: 'Inputs to',
                                },
                                return: {
                                    text: 'Returns',
                                    desc: 'Outputs from',
                                },
                                trait: {
                                    text: 'Traits',
                                    desc: 'Member traits from',
                                },
                                constant: {
                                    text: 'Constants',
                                    desc: 'Constants associated with',
                                },
                                // unused
                                module: {
                                    text: 'Modules',
                                    desc: '[ERROR]',
                                },
                            };
                            const { text, desc } = mapping[kind];
                            return <>
                                <Comment hDepth={innerDepth}>
                                    {text}
                                    <Fragment slot="tooltip">
                                        {desc} the <LilRef item={item} onPage/> {item.data.kind}
                                    </Fragment>
                                </Comment>
                                {childrenOfKind}
                            </>
                        })}
                    </ScopeBlock>
                </>
            });
        }
        return tree.map((module) => <div class="module-column">{renderTree([module], 1)}</div>);
    }}
    </main>
</PageBase>
