---
import { getCollection } from "astro:content";
import PageBase from "../layouts/PageBase.astro";
import { kinds, type GlossaryEntry, type Kind, type ValidGlossarySlug } from "../scripts/glossary";
import ScopeBlock from "../components/ScopeBlock.astro";
import Ref from "../components/Ref.astro";
import Keyword from "../components/syntax/Keyword.astro";
import Comment from "../components/syntax/Comment.astro";
import Heading from "../components/Heading.astro";
import Punc from "../components/syntax/Punc.astro";
import TypeUnion from "../components/TypeUnion.astro";
import ScopeInline from "../components/ScopeInline.astro";
import { getEntry } from "astro:content";

const getChildren = async (parent: ValidGlossarySlug, filter?: (entry: GlossaryEntry) => boolean): Promise<GlossaryEntry[]> => {
    const parentPath = parent.split('/');
    return await getCollection('glossary', (entry: GlossaryEntry) => {
        const path = entry.slug.split('/');
        const isChild = path.length === parentPath.length + 1 && path.slice(0, -1).every((part, index) => part === parentPath[index]);
        return isChild && (!filter || filter(entry));
    });
};

interface GlossaryTreeNode {
    item: GlossaryEntry;
    childrenByKind: [Kind, GlossaryTreeNode[]][];
}

const getChildrenRecursively = async (root: GlossaryEntry): Promise<GlossaryTreeNode> => {
    const item: GlossaryEntry = root;

    const immediateChildrenByKind: [Kind, GlossaryEntry[]][] = await Promise.all(kinds
        .map(async (kind) => {
            const childItems: GlossaryEntry[] = await getChildren(item.slug, (entry) => entry.data.kind === kind);
            return [kind, childItems];
        })
    );

    const whereExisting: [Kind, GlossaryEntry[]][] = immediateChildrenByKind
        .filter(([_, entries]) => entries.length !== 0);

    const childrenByKindRecursively: [Kind, GlossaryTreeNode[]][] = await Promise.all(whereExisting
        .map(async ([kind, entries]: [Kind, GlossaryEntry[]]) => {
            const recursiveChildren: GlossaryTreeNode[] = await Promise.all(entries.map(getChildrenRecursively));
            return [kind, recursiveChildren];
        })
    );

    const node: GlossaryTreeNode = { item, childrenByKind: childrenByKindRecursively };
    return node;
};

const modules = await getCollection('glossary', (entry) => !entry.slug.includes('/'));

const tree: GlossaryTreeNode[] = await Promise.all(modules.map(getChildrenRecursively));

// Debug
const debugTreeRecursively = (nodes: GlossaryTreeNode[]) => {
    nodes.forEach((node: GlossaryTreeNode) => {
        console.group('- ' + node.item.slug.split('/').at(-1));
        node.childrenByKind.forEach(([kind, children]: [Kind, GlossaryTreeNode[]]) => {
            console.log(kind);
            debugTreeRecursively(children);
        });
        console.groupEnd();
    });
}
debugTreeRecursively(tree);

const properCase = (kind: Kind): string => {
    const mapping: Record<Kind, string> = {
        function:  'Methods',
        type:      'Types',
        field:     'Fields',
        parameter: 'Arguments',
        trait:     'Traits',
        module:    'Modules', // unused
    };
    return mapping[kind];
}
---

<PageBase title="Amy's STEM Notes">
    <Fragment slot="head">
        <style>
            main {
                display: flex;
                flex-flow: row nowrap;
                gap: 3em;
            }
        </style>
    </Fragment>
    <main>
    {() => {
        const renderTree = async (nodes: GlossaryTreeNode[], depth: number) => {
            return nodes.map(async (node: GlossaryTreeNode) => {
                const { item } = node;
                const renderedChildren = await Promise.all(node.childrenByKind.map(
                    async ([kind, children]): Promise<[Kind, any[]]> => [kind, await renderTree(children, depth + 1)]
                ));
                const Description = (await item.render()).Content;
                const innerDepth = depth + 1;
                return <>
                    <ScopeBlock>
                        {/* Title */}
                        <Fragment slot="summary">
                                {() => {
                                    const id = item.slug.replace(/\//g, '+');
                                    switch (item.data.kind) {
                                        case 'function':
                                            return <>
                                                <Heading depth={depth} id={id}>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item} onPage/>
                                                </Heading>
                                                <div style="display:flex;flex-flow:row nowrap;gap:1ch;align-items:center;">
                                                    <ScopeBlock delim="paren" horizontal>
                                                        <table class="parameter-list">{
                                                            item.data.parameters!.map(async (ref) => {
                                                                const param = await getEntry(ref);
                                                                return <tr>
                                                                    <td><Ref item={param} onPage/><Punc ch=":"/></td>
                                                                    <td><TypeUnion list={param.data.typeUnion!} onPage/><Punc ch=","/></td>
                                                                </tr>
                                                            }
                                                        )}</table>
                                                    </ScopeBlock>
                                                    <span class="keyword">&rArr;</span>
                                                    <ScopeBlock delim="brace" horizontal>
                                                        <table class="parameter-list">
                                                        {Object.entries(item.data.returns!).map(([ret, typeUnion]) => <tr>
                                                            <td><span class="return">{ret}</span><Punc ch=":"/></td>
                                                            <td><TypeUnion list={typeUnion} onPage/><Punc ch=","/></td>
                                                        </tr>)}
                                                        </table>
                                                    </ScopeBlock>
                                                </div>
                                            </>;

                                        case 'field':
                                            return <>
                                                <Heading depth={depth} id={id}>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item} onPage/><Punc ch=":"/>
                                                    <TypeUnion list={item.data.typeUnion!} onPage/><Punc ch=";"/>
                                                </Heading>
                                            </>;

                                        case 'parameter':
                                            return <>
                                                <Heading depth={depth} id={id}>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <span class="type">&lbrace;</span>
                                                    <TypeUnion list={item.data.typeUnion!} onPage/>
                                                    <span class="type">&rbrace;</span>
                                                    <Ref item={item} onPage/>
                                                </Heading>
                                            </>;

                                        case 'type':
                                        case 'trait':
                                            return <>
                                                <Heading depth={depth} id={id}>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item} onPage/>
                                                </Heading>
                                            </>;

                                        default:
                                            return <>
                                                <Heading depth={depth} id={id}>
                                                    <Keyword tkn={item.data.kind}/>
                                                    <Ref item={item} onPage/>
                                                </Heading>
                                            </>;
                                    }
                                }}
                        </Fragment>

                        {/* Aliases */}
                        {item.data.aliases && <>
                            <Heading depth={innerDepth}><Comment>Aliases</Comment></Heading>
                            <table class="alias-list">{
                                Object.entries(item.data.aliases).map(([alias, kind]) => <tr>
                                    <td><Keyword tkn="static"/> <Keyword tkn={kind}/></td>
                                    <td>&nbsp;<Ref item={item} overrideKind={kind} onPage alias>{alias}</Ref></td>
                                    <td>&nbsp;<Punc ch={kind === item.data.kind ? '=' : '~'}/>&nbsp;<Ref item={item} onPage/><Punc ch=";"/></td>
                                </tr>)
                            }</table>
                        </>}

                        {/* Description */}
                        <Heading depth={innerDepth}><Comment>Description</Comment></Heading>
                        <div class="item-description">
                            <Description/>
                        </div>

                        {/* Children */}
                        {renderedChildren.map(([kind, childrenOfKind]) => <>
                            <Heading depth={innerDepth}><Comment>{properCase(kind)}</Comment></Heading>
                            {childrenOfKind}
                        </>)}
                    </ScopeBlock>
                </>
            });
        }
        return tree.map((module) => <div class="module-column">{renderTree([module], 1)}</div>);
    }}
    </main>
</PageBase>
