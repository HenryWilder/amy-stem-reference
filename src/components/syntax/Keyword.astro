---
import { type Kind, kinds } from '../../scripts/glossary';
import Tooltip from '../Tooltip.astro';

const validKeywords = [
    ...kinds,
    'null',
    'becomes',
    'maps to',
    'implies',
    'type annotation',
    'type union',
    'type intersection',
    'static',
    'instance',
    'member',
    'method',
    'property',
    'extends',
    'implements',
    'assign',
    'similar to',
    'end of statement',
    'separator',
    'combine traits',
    'for',
] as const;

type ValidKindSeparator = `${'static ' | 'instance ' | ''}${Kind} separator`; // instance if blank

export type ValidKeyword = (typeof validKeywords)[number] | ValidKindSeparator;

type NeedsContext =
    | 'implements'
    | 'extends'
    | 'assign'
    | 'similar to'
    | 'separator'
    | 'becomes'
    | 'maps to'
    | 'implies'
    | 'type annotation'
    | 'type union'
    | 'type intersection'
    | 'combine traits'
    | ValidKindSeparator;

type Props = {
    fullName?: true;
} & ({
        tkn: Exclude<ValidKeyword, NeedsContext>;
        prev?: undefined;
        next? : undefined;
    } | {
        tkn: NeedsContext;
        prev: any;
        next: any;
    }
);

const { tkn, prev = 'ERR', next = 'ERR', fullName } = Astro.props;

type TokenData = { symbol: any, description: any, keywordType?: 'keyword' | 'control' | 'operator' };

if (fullName && Astro.slots.has('default')) {
    console.warn(
        `Using the 'fullName' property on a Keyword using the default slot is redundant.\n` +
        `  The slot ("${await Astro.slots.render('default')}") will take priority over the non-symbolic name of the keyword ("${tkn}").`);
}
---

{() => {
    const tokenData: TokenData = (() => {
        switch (tkn) {
            case 'for':
                return {
                    symbol: <>&forall;</>,
                    description: <>
                        Repeat for every element.
                    </>,
                    keywordType: 'control',
                };
            case 'assign':
                return {
                    symbol: '=',
                    description: <>
                        {prev}&nbsp;is the same as&nbsp;{next}.
                    </>,
                    keywordType: 'operator',
                };
            case 'similar to':
                return {
                    symbol: '~',
                    description: <>
                        {prev}&nbsp;is similar to&nbsp;{next}.
                    </>,
                    keywordType: 'operator',
                };
            case 'separator':
                return {
                    symbol: ',',
                    description: <>
                        {prev}&nbsp;is followed by&nbsp;{next}.
                    </>,
                    keywordType: 'operator',
                };
            case 'end of statement':
                return {
                    symbol: ';',
                    description: <>
                        The statement is complete.
                    </>,
                    keywordType: 'operator',
                };
            case 'becomes':
                return {
                    symbol: <>&rarr;</>,
                    description: <>
                        {prev}&nbsp;becomes&nbsp;{next}.
                    </>,
                };
            case 'maps to':
                return {
                    symbol: <>&mapsto;</>,
                    description: <>
                        {prev}&nbsp;maps to&nbsp;{next}.
                    </>,
                };
            case 'implies':
                return {
                    symbol: <>&rArr;</>,
                    description: <>
                        {prev}&nbsp;implies&nbsp;{next}.
                    </>,
                };
            case 'type annotation':
                return {
                    symbol: ':',
                    description: <>
                        {prev}&nbsp;is of the&nbsp;<Astro.self fullName tkn="type"/>&nbsp;described by&nbsp;{next}.
                    </>,
                    keywordType: 'operator',
                };
            case 'type union':
                return {
                    symbol: <>&or;</>,
                    description: [<>
                        The union of&nbsp;<Astro.self tkn="type">types</Astro.self>.
                    </>, <>
                        (<Astro.self fullName tkn="type"/>&nbsp;{prev}&nbsp;<em>or</em>&nbsp;<Astro.self fullName tkn="type"/>&nbsp;{next}).
                    </>],
                    keywordType: 'operator',
                };
            case 'type intersection':
                return {
                    symbol: <>&and;</>,
                    description: [<>
                        The intersection of&nbsp;<Astro.self tkn="type">types</Astro.self>.
                    </>, <>
                        (<Astro.self fullName tkn="type"/>&nbsp;{prev}&nbsp;<em>and</em>&nbsp;<Astro.self fullName tkn="type"/>&nbsp;{next}).
                    </>],
                    keywordType: 'operator',
                };
            case 'combine traits':
                return {
                    symbol: '+',
                    description: [<>
                        Combines multiple&nbsp;<Astro.self tkn="trait">traits</Astro.self>&nbsp;to be&nbsp;<Astro.self tkn="implements" prev={prev} next={next}>implemented</Astro.self>.
                    </>, <>
                        (<Astro.self fullName tkn="implements" prev={prev} next={next}
                        />&nbsp;<Astro.self fullName tkn="trait"/>&nbsp;{prev}&nbsp;<em>and</em>&nbsp;<Astro.self fullName tkn="trait"/>&nbsp;{next}).
                    </>],
                    keywordType: 'operator',
                };
            case 'function':
                return {
                    symbol: 'fn',
                    description: <>
                        Takes input and produces output.
                    </>,
                };
            case 'method':
                return {
                    symbol: 'fn',
                    description: <>
                        An&nbsp;<Astro.self fullName tkn="instance"/>&nbsp;<Astro.self fullName tkn="member"/>&nbsp;<Astro.self fullName tkn="function"
                        />&nbsp;of a&nbsp;<Astro.self fullName tkn="type"/>.
                    </>,
                };
            case 'module':
                return {
                    symbol: 'mod',
                    description: <>
                        An entire area of a study.
                    </>,
                };
            case 'field':
                return {
                    symbol: 'pub',
                    description: <>
                        A variable part of an object.
                    </>,
                };
            case 'property':
                return {
                    symbol: '@property',
                    description: <>
                        A&nbsp;<Astro.self fullName tkn="field"/>-like&nbsp;<Astro.self fullName tkn="method"/>.
                    </>,
                };
            case 'parameter':
                return {
                    symbol: '@param',
                    description: <>
                        An input to a&nbsp;<Astro.self fullName tkn="function"/>.
                    </>,
                };
            case 'return':
                return {
                    symbol: '@return',
                    description: <>
                        An output from a&nbsp;<Astro.self fullName tkn="function"/>.
                    </>,
                };
            case 'implements':
                return {
                    symbol: 'impl',
                    description: <>
                        {prev}&nbsp;follows the template of the&nbsp;<Astro.self fullName tkn="trait"/>(s) '{next}'.
                    </>,
                };
            case 'extends':
                return {
                    symbol: 'extends',
                    description: <>
                        {prev}&nbsp;builds upon the template of the&nbsp;<Astro.self fullName tkn="type"/>(s) '{next}'.
                    </>,
                };
            case 'null':
                return {
                    symbol: 'null',
                    description: <>
                        Nothing.
                    </>,
                };
            case 'static':
                return {
                    symbol: 'static',
                    description: <>
                        External to the object possessing it.
                    </>,
                };
            case 'instance':
                return {
                    symbol: 'instance',
                    description: <>
                        Specific to an example or real world copy the object possessing it.
                    </>,
                };
            case 'member':
                return {
                    symbol: 'member',
                    description: <>
                        Belonging to another object or&nbsp;<Astro.self fullName tkn="module"/>.
                    </>,
                };
            case 'type':
                return {
                    symbol: 'type',
                    description: <>
                        An object structure.
                    </>,
                };
            case 'trait':
                return {
                    symbol: 'trait',
                    description: <>
                        A template or guide describing the generalized&nbsp;<Astro.self tkn="property">properties</Astro.self>&nbsp;of a&nbsp;<Astro.self fullName tkn="type"/>.
                    </>,
                };
            case 'constant':
                return {
                    symbol: 'const',
                    description: <>
                        An unchanging value.
                    </>,
                };
            default:
                const kindSeparator: RegExpExecArray | null = RegExp(`^(?:(static|instance) )?(${kinds.join('|')}) separator$`).exec(tkn);
                if (kindSeparator !== null) {
                    const [_, staticity = 'static', kind] = kindSeparator as string[] as [string, 'static' | 'instance' | undefined, Kind];

                    const symbol = kind === 'parameter' || kind === 'return'
                        ? '@'
                        : staticity === 'instance'
                            ? '#'
                            : '::';

                    const aOrAn = staticity[0].match(/[aeiou]/i) ? 'an' : 'a';
                    return {
                        symbol,
                        description: <>
                            {next}&nbsp;is&nbsp;{aOrAn
                            }&nbsp;<Astro.self fullName tkn={staticity}
                            />&nbsp;<Astro.self fullName tkn="member"
                            />&nbsp;<Astro.self fullName tkn={kind}
                            />&nbsp;within&nbsp;{prev}.
                        </>,
                        keywordType: 'operator',
                    }
                } else {
                    throw new Error(`The token '${tkn}' has not been handled`);
                }
        }
    })();

    const { symbol, description, keywordType = 'keyword' } = tokenData;

    return <Tooltip>
        <span class={keywordType}><slot>{fullName ? tkn : symbol}</slot></span>
        <Fragment slot="content">
            <p class={keywordType}>'{tkn}' {keywordType}</p>
            {() => {
                const wrapper = (inner: any) => <div style="display:flex;flex-flow:row-nowrap;align-items: center;">{inner}</div>;

                return Array.isArray(description)
                    ? description.map((line) => wrapper(line))
                    : wrapper(description);
            }}
        </Fragment>
    </Tooltip>;
}}
