---
// import type { Item, ItemLink } from '../scripts/glossary';
// import { getGlossaryItem, type GlossaryItem, type ItemPath, type DescriptionLine } from '../scripts/glossary';
// import { relToPath } from '../scripts/glossary-data';
// import Katex from './Katex.astro';
// import LilRef from './LilRef.astro';
// import Ref from './Ref.astro';

// interface Props {
//     /** The item we want the description of */
//     item: Item;

//     /** brief: only use first paragraph */
//     brevity: 'full' | 'brief';

//     /** inline: display as <span> insteaad of <p> */
//     display: 'block' | 'inline';

//     /** Whether the links should have a tooltip or not */
//     links: 'tooltip' | 'no-tooltip';
// }

// const { item, brevity, display, links } = Astro.props;

// const description: string = (() => {
//     switch (brevity) {
//         case 'full':
//             return item.description;

//         case 'brief':
//             return item.brief;
//     }
// })();

// const isTex = (x: ItemLink | { tex: string }): x is { tex: string } => Object.hasOwn(x, 'tex');
---

<!-- {
    description.map((line) => {
        const inner = line.map((segment) => {
            if (typeof segment === 'string') {
                return segment;
            } else if (isTex(segment)) {
                return <Katex tex={segment.tex}/>;
            } else {
                const { text } = segment;
                const relPath = relToPath(path, segment.rel);
                switch (links) {
                    case 'tooltip':
                        return <Ref text={text} path={relPath}/>;

                    // Because using tooltips inside of tooltips risks infinite recursion.
                    case 'no-tooltip':
                        return <LilRef text={text} path={relPath}/>;
                }
            }
        })
        switch (display) {
            case 'block':
                return <p>{inner}</p>;

            case 'inline':
                return <span>{inner}</span>;
        }
    })
} -->
